# データ
## newによる割り当て
Go言語の基本的なメモリ割り当てには、**newとmake**の2つの組み込み関数が用意されている。

**メモリの割当を行う組み込み関数**だが、多言語のnewの多くと異なり、**メモリの初期化でなく、ゼロ化のみを行う**。すなわち、new(T)は、**型Tの新しいアイテム用にゼロ化した領域を割り当て、そのアドレスである\*T型の値を返す**。Go言語風に言い換えると、、**new(T)が返す値は、新しく割り当てられた型Tのゼロ値のポインタ**。

ゼロ化済みオブジェクトは、さらなる初期化を行わなくても使用できるため、こういったオブジェクトの準備にnewは便利。すなわち、**データ構造体の利用者がnewでそれを作成すると、すぐに使える状態となる。**例えば、byte.Bufferのドキュメントには、「Bufferのゼロ値は、利用準備が整ったからのバッファである」と記述されている。同様にsync.Mutexには明示的なコンストラクタやInitメソッドは用意されていないが、そのかわりにsync.Mutexのゼロ値は、非ロック状態のミューテックスであること定められている。

この便利なゼロ値は連鎖的に働く。
```golang
type SyncedBuffer struct {
    lock   syc.Mutex
    buffer bytes.Buffer
}
```
このSyncedBuffer型の値もまた、割り当てや宣言を行うと同時に準備が整う。下のコードの変数pとvは、このままで正しく機能する
```golang
p := new(SyncedBuffer)  // *SyncedBuffer型
var v SyncedBuffer      // SyncedBuffer型
```

## コンスタラクタと複合リテラル
以下のように、ゼロ値では十分でなく、コンスタラクタによる初期化が必要になることがある。
```golang
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```
上のコードには冗長な部分が多い。**複合リテラル**とは、**実行するたびに新しいインスタンスを生成する式**であり、これを使うことで以下のコードのように単純化することができる。
```golang
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd,name,nil,0}
    return &f
}
```
C言語床となり、このようにローカル変数のアドレスを返して問題ない。関数から戻ったあとも、変数に割り当てたメモリは生き残る。複合リテラルのアドレスを取得したときは、実行するたびにインスタンスが割り当てられる使用なので、最後の2行を次のようにまとめることができる。
```golang
return &File{fd,name,nil,0}
```
複合リテルでは、**すべてのフィールドを順番通りに記述しなければならない**。ただし、明示的に「フィールド：値」の組み合わせで要素にラベルを付けたときは、イニシャライザは順序どおりである必要はなく、またしてしなかった要素には、その型のゼロ値がセットされる。すなわち次のように書き換えられる。
```golang
return &File{fd: fd, name: name}
```
特殊なケースとして、**複合リテラルが一つでもフィールドを含まないときは、その型のゼロ値が作られる**。すなわち、**式new(File)と&File{}**は等価。

また複合リテラルでは、フィールドのラベルをインデックスまたはマップのキーとみなして、配列、スライス、マップを作成することもできる。次の例において、Enone、Eio、Einvalがそれぞれ個別の変数でありさえすれば、その値にかかわらず初期化は成功する。
```golang
a := [...]string {Enone: "no error", Eio: "Eio",Einval: "invalid argument"}
s := []string {Enone: "no error", Eio: "Eio",Einval: "invalid argument"}
m := map[int]string {Enone: "no error", Eio: "Eio",Einval: "invalid argument"}
```

## makeによる割り当て
組み込み関数make(T,args)は、new(T)とは使用目的が異なる。makeで割り当てできるのは**スライス、マップ、チャネル**だけであり、初期化された、すなわちゼロ値でないT型(*Tでない)の値を返す。makeとnewを使い分ける理由は、これらの3つの型が隠蔽されたデータ構造への参照であり、このデータ構造が使用前に初期化されている必要があるため。スライスを例に取ると、スライスはデータ(配列内)へのポインタ、長さ、キャパシティという3つの情報から構成されており、それらの情報が初期化されるまではスライスの値はnil。makeはスライス、マップ、チャネルの内部データ構造を初期化し、使用可能となるよう値を準備する。したはmakeの例。
```golang
make([]int, 10, 100)
```
この例では、100個のintを持つ配列を割り当てた後,その配列の先頭から10個目までの要素を示す、長さが10でキャパシティ100のスライス構造を作成する。(スライス作成時、キャパシティは省略可能。)これに対して、new([]int)は新しくメモリを割り当て、ゼロ化舌スライス構造のポインタを返す。つまりこれはnilスライス値へのポインタである。