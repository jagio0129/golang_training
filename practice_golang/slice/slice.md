# スライス
- 要素の集合体で配列とよく似ている
- インデックスでアクセス可能
- **スライス自体は要素データを持っていない**
  - 実際はそのスライスに紐付けられた入れうtの持つ要素が間接的に参照される。
- 配列を直接扱うよりもスライスを経由して扱うほうが利便性が高い

## スライスは参照型
- スライスの他にマップとチャネルという2種類の参照型がある
- 参照型は、データの実体を持たず、データへの参照情報しか持たない
- 配列の値を関数間で受け渡すと、受け渡し先で配列の要素が全てコピーされ、メモリを食い処理時間がかかる。
  - スライスは参照情報を渡すのでデータ量に左右されることはない。
  - 参照渡しなのでデータは元を変更することになる。

```go
func slice01() {
	x := [...]int{0, 1, 2, 3, 4, 5}
	var s []int

  //配列をスライスにして関数へ渡す
	s = x[:]
	double(s)

	fmt.Println(s)
}

// 各要素を2倍に
func double(values []int) {
	for i := 0; i < len(values); i++ {
		values[i] *= 2
	}
}
```

## スライスのキャパシティ
- 組み込み関数`cap()`で取得できる**キャパシティ**という値を持っている
  - この値は、スライスから新たなスライスを作成するときにスライス式に指定できる上限値の最大値

```go
func slice02() {
	array := [...]int{0, 1, 2, 3, 4, 5}

	// 配列をスライス
	s1 := array[1:3]
	fmt.Println(s1)
	fmt.Println("len:", len(s1))
	fmt.Println("cap:", cap(s1))

	//スライスをスライス
	s2 := s1[1:4]
	fmt.Println(s2)
	fmt.Println("len:", len(s2))
	fmt.Println("cap:", cap(s2))

	s3 := s1[1:3:4]
	fmt.Println(s3)
	fmt.Println("len:", len(s3))
	fmt.Println("cap:", cap(s3))
}
```

## 文字列のスライス
- 文字列内のバイト単位でスライスが行われるため、**日本語のように1文字で複数バイトを使用する文字の場合は正しく文字列の切り出しができないことがあるため注意が必要**
```go
func slice03() {
	//文字列のスライス
	var x string = "abcdefg"[1:4]

	//ひらがなはUTF-8で3バイトなので「いう」が取り出せる
	var y string = "あいうえお"[3:9]

	//UTF-8の文字の境界として不適切な値を指定すると文字化けする
	var z string = "あいうえお"[1:4]

	//出力
	fmt.Println(x)
	fmt.Println(y)
	fmt.Println(z)
}
```
